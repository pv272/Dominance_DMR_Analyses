---
title: "EloCalculation"
author: "Philippe"
date: "12 November 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---


We are goint to calculate the dominance index using elo rating in our captive population of Damaraland mole-rat 

```{r setup, include=FALSE}
library(RMySQL)
library(getPass)
library(EloRating)
library(tidyverse)
library(lubridate)
```

We start by establishing a connection with the database
```{r Database connection}
con <- dbConnect(MySQL(), user = 'philippev',password = getPass(),  
                 dbname = 'Moleratdatabase', host = 'Kalahariresearch.org')

#set seed to get always the same randomization
set.seed(123)
```



```{r database extract}

#To check for possible errors, we must extract the group composition on every day of obervation. At the moment this is exctracted using the GroupComp query done by Tim Vink but which could be made much easier with the use of lead and lag function.

GroupComp<- con %>%
  dbGetQuery ("SELECT 
    *
FROM
    user_philippev.DatesFilledRange
        INNER JOIN
    (SELECT 
        `AnimalID`,
        `tblAnimalID`.`Rowref`,
            `DateMoved` `MemberFrom`,
            `DateTo` `MemberTo`,
            `Colony`,
            TIMESTAMPDIFF(DAY, `DateMoved`, DateTo) AS `MemberDays`
    FROM
        (SELECT 
        `AnimalID`,
            `DateMoved`,
            `ColonyRef`,
            CASE
                WHEN
                    @lastIndiv = `tblColonyMembership`.`AnimalID`
                        AND @lastDateMoved <> tblColonyMembership.DateMoved
                THEN
                    @lastDateMoved
                ELSE @lastDateMoved:=NOW()
            END AS `DateTo`,
            @lastIndiv:=`tblColonyMembership`.`AnimalID` `PreviousIndivid`,
            @lastDateMoved:=`tblColonyMembership`.`DateMoved` `PreviousDateMoved`
    FROM
        (SELECT 
        @lastIndiv:='',
            @lastdatetime:=DATE(0),
            @lastDateMoved:=DATE(0),
            UPPER(tblColonyMembership.AnimalID) AnimalID,
            DateMoved,
            tblColonyMembership.ColonyRef,
            CurrentPop
    FROM
        `Moleratdatabase`.`tblColonyMembership`
    LEFT JOIN `Moleratdatabase`.`tblPlace` USING (AnimalID)
    WHERE
        CurrentPop = 'L'
    ORDER BY tblColonyMembership.AnimalID , DateMoved DESC) `tblColonyMembership`
    ) AS `tmp`
    INNER JOIN `Moleratdatabase`.`tblColonyCodes` USING (`ColonyRef`)
    INNER JOIN `Moleratdatabase`.`tblSex` USING (`AnimalID`)
    INNER JOIN `Moleratdatabase`.`tblAnimalID` USING (`AnimalID`)) AS `betweenqry` ON filldate BETWEEN betweenqry.MemberFrom AND betweenqry.MemberTo - INTERVAL 1 DAY 
WHERE
    Colony <> 'DEAD'
ORDER BY AnimalID , filldate") %>% 
  mutate(filldate=as.Date(filldate)) %>% 
  select(Colony,filldate,AnimalID) %>% 
  rename(ColonyExtracted=Colony)#I rename for when I want to do my datacheck later on and see whether the colony name from observation is the same than the one extracted from Group comp

# I need the sex of the winner and loser to distinguish between the different type of interactions
Sex<-con %>% 
  dbGetQuery("SELECT *
FROM Moleratdatabase.tblSex
") %>% 
  select(AnimalID,Sex)

```


## Preparation of sub call dataset 

Extract the sub call from the scan and the focal data from the old fashion import. Thus most recend data are missing. The new fashion way will have to be added which will require a few axtra steps
```{r SubCall}

#scan call
ScanCall <- con %>%
  dbGetQuery("SELECT *
FROM user_philippev.SubCall_Scan
") %>% 
mutate(ObsDate=as.Date(ObsDate)) %>% 
    lapply(., function(x) rep(x,.$BehaviourCount)) %>% #to repeat the rows for interactions that have happened several times
  as.data.frame(.) %>% 
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Loser" = "AnimalID")) %>% #this is to exclude rows where recorded loser were not part of the correct group
  rename(ColonyExtractedLoser = ColonyExtracted) %>% 
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID")) %>% 
   rename(ColonyExtractedWinner = ColonyExtracted)

# filter(Colony != ColonyExtractedLoser & Colony != ColonyExtractedWinner)
  
nrow(ScanCall)
#17780 rows before any joins 
#17766 after joining on loserID and Date 
#17189 after joining on WinnerID and Date. That is very strange why I lose so many rows there
#I can exclude further with when mismatch between colony and colony extracted 


#try to identify the loss of 600 rows or so 
ScanCall_NoWinner <- con %>%
  dbGetQuery("SELECT *
FROM user_philippev.SubCall_Scan
") %>% 
mutate(ObsDate=as.Date(ObsDate)) %>% 
    lapply(., function(x) rep(x,.$BehaviourCount)) %>% #to repeat the rows for interactions that have happened several times
  as.data.frame(.) %>% 
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Loser" = "AnimalID")) %>% #this is to exclude rows where recorded loser were not part of the correct group
  rename(ColonyExtractedLoser = ColonyExtracted) %>% 
left_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID")) %>% 
   rename(ColonyExtractedWinner = ColonyExtracted)

setdiff(ScanCall_NoWinner,ScanCall)
names(ScanCall)
names(ScanCall_NoWinner)
x <- anti_join( ScanCall_NoWinner, ScanCall)
nrow(x)
summary(x)
    inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Loser" = "AnimalID","Colony"="ColonyExtracted" )) %>% #this is to exclude rows where recorded loser were not part of the correct group
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID","Colony"="ColonyExtracted" ))  #this is to exclude rows where recorded winner were not part of the correct group


#displaying the mismatch between the colony from the scan file and the colony names extracted from the database. I do not know what those All colonies are 
Scan_ColMismatch<- con %>%
  dbGetQuery("SELECT *
FROM user_philippev.SubCall_Scan
") %>% 
mutate(ObsDate=as.Date(ObsDate)) %>% 
    lapply(., function(x) rep(x,.$BehaviourCount)) %>% #to repeat the rows for interactions that have happened several times
  as.data.frame(.) %>% 
  inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID")) %>% 
  filter(Colony != ColonyExtracted)
  
  
  
    inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Loser" = "AnimalID")) %>% #this is to exclude rows where recorded loser were not part of the correct group
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID")) %>%  #this is to exclude rows where recorded winner were not part of the correct group
  filter(Colony != ColonyExtracted.x|Colony != ColonyExtracted.y)

    
names(Scan_ColMismatch)
View(Scan_ColMismatch)#There are 74 rows that are lost



  

nrow(ScanCall)#17780, 1715 if animal not from the same colony 


#focal calls
FocalCall <- con %>%
dbGetQuery("SELECT * FROM user_philippev.SubCall_Focal") %>% 
mutate(ObsDate=as.Date(ObsDate)) %>% 
rename(NBCall=NbCall) %>% 
lapply(., function(x) rep(x,.$BehaviourCount)) %>% 
as.data.frame(.)#to repeat the rows for interactions that have happened several times

```


For the focal data, we the winner and the loser in a different column. In the current table this is given by the value in the column Received where 0 means winner and 1 means loser

```{r Focal Wrangling}

###Make use of the Received modifier to determine the winner and loser of each interaction and put the focal data in a format that it can be joined to scan data 
FocalCall_Tidy<- FocalCall %>% 
  filter (Received == 1) %>% 
  rename(Loser=AnimalID, Winner=Partner) %>% 
  bind_rows(FocalCall %>% 
  filter (Received == 0) %>% 
  rename(Winner=AnimalID, Loser=Partner)) %>% 
  select(-Received)

#I could add the label of the context here 

```


We can now bind the focal and the scan data together
```{r}
SubCall_All<-FocalCall_Tidy %>% 
  bind_rows(ScanCall) %>% 
  filter (Winner != Loser) %>% #eliminate animals that interacts with themselves
  inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Loser" = "AnimalID","Colony"="Colony" )) %>% #this is to exclude rows where recorded loser were not part of the correct group
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID","Colony"="Colony" )) %>% #this is to exclude rows where recorded winner were not part of the correct group
  select(-BehaviourCount) %>% 
  arrange(ObsDate) %>% 
  inner_join(., Sex, by=c("Winner"="AnimalID")) %>% # add the sex of the winner
  rename(SexWinner=Sex) %>% 
  inner_join(., Sex, by=c("Loser"="AnimalID")) %>% #add the sex of the loser
  rename(SexLoser=Sex) %>% 
  group_by(ObsRef,ObsType) %>%
  sample_frac(size = 1, replace = FALSE)#randomize all row within each observation per type of observation
  
nrow(SubCall_All)

write.csv(SubCall_All,"SubCall.csv",row.names = FALSE)

SubCall <- read.csv("SubCall.csv")

# I lose from 29822 to 29771 when I exclude individuals that interacted with each other
#I lose from 29771 to 28733 when I exclude animals for which there is a mismatch in the colony that is quite a lot and need fixing. I think the likelihood of mistake is higher in scan and perhaps I could fileter out separately  

#The context given a number is wrong BECAUSE the value between scan and focal are not corresponding. Thus I would beed to bering the text. But for now it has no importance

```

## Preparation of pass data set 
The idea will be to generate the elo score using pass 


