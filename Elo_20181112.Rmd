---
title: "EloCalculation"
author: "Philippe"
date: "12 November 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---


We are goint to calculate the dominance index using elo rating in our captive population of Damaraland mole-rat 

```{r setup, include=FALSE}
library(RMySQL)
library(getPass)
library(EloRating)
library(tidyverse)
library(lubridate)
```

We start by establishing a connection with the database
```{r Database connection}
con <- dbConnect(MySQL(), user = 'philippev',password = getPass(),  
                 dbname = 'Moleratdatabase', host = 'Kalahariresearch.org')

#set seed to get always the same randomization
set.seed(123)
```



```{r database extract}

#To check for possible errors, we must extract the group composition on every day of obervation. At the moment this is exctracted using the GroupComp query done by Tim Vink but which could be made much easier with the use of lead and lag function.

GroupComp<- con %>%
  dbGetQuery ("SELECT 
    *
FROM
    user_philippev.DatesFilledRange
        INNER JOIN
    (SELECT 
        `AnimalID`,
        `tblAnimalID`.`Rowref`,
            `DateMoved` `MemberFrom`,
            `DateTo` `MemberTo`,
            `Colony`,
            TIMESTAMPDIFF(DAY, `DateMoved`, DateTo) AS `MemberDays`
    FROM
        (SELECT 
        `AnimalID`,
            `DateMoved`,
            `ColonyRef`,
            CASE
                WHEN
                    @lastIndiv = `tblColonyMembership`.`AnimalID`
                        AND @lastDateMoved <> tblColonyMembership.DateMoved
                THEN
                    @lastDateMoved
                ELSE @lastDateMoved:=NOW()
            END AS `DateTo`,
            @lastIndiv:=`tblColonyMembership`.`AnimalID` `PreviousIndivid`,
            @lastDateMoved:=`tblColonyMembership`.`DateMoved` `PreviousDateMoved`
    FROM
        (SELECT 
        @lastIndiv:='',
            @lastdatetime:=DATE(0),
            @lastDateMoved:=DATE(0),
            UPPER(tblColonyMembership.AnimalID) AnimalID,
            DateMoved,
            tblColonyMembership.ColonyRef,
            CurrentPop
    FROM
        `Moleratdatabase`.`tblColonyMembership`
    LEFT JOIN `Moleratdatabase`.`tblPlace` USING (AnimalID)
    WHERE
        CurrentPop = 'L'
    ORDER BY tblColonyMembership.AnimalID , DateMoved DESC) `tblColonyMembership`
    ) AS `tmp`
    INNER JOIN `Moleratdatabase`.`tblColonyCodes` USING (`ColonyRef`)
    INNER JOIN `Moleratdatabase`.`tblSex` USING (`AnimalID`)
    INNER JOIN `Moleratdatabase`.`tblAnimalID` USING (`AnimalID`)) AS `betweenqry` ON filldate BETWEEN betweenqry.MemberFrom AND betweenqry.MemberTo - INTERVAL 1 DAY 
WHERE
    Colony <> 'DEAD'
ORDER BY AnimalID , filldate") %>% 
  mutate(filldate=as.Date(filldate)) %>% 
  select(Colony,filldate,AnimalID) %>% 
  rename(ColonyExtracted=Colony)#I rename for when I want to do my datacheck later on and see whether the colony name from observation is the same than the one extracted from Group comp

# I need the sex of the winner and loser to distinguish between the different type of interactions
Sex<-con %>% 
  dbGetQuery("SELECT *
FROM Moleratdatabase.tblSex
") %>% 
  select(AnimalID,Sex)

```


## Preparation of sub call dataset 

Extract the sub call from the scan and the focal data from the old fashion import. Thus most recend data are missing. The new fashion way will have to be added which will require a few axtra steps
```{r SubCall}

#scan call
ScanCall <- con %>%
  dbGetQuery("SELECT *
FROM user_philippev.SubCall_Scan
") %>% 
mutate(ObsDate=as.Date(ObsDate)) %>% 
    lapply(., function(x) rep(x,.$BehaviourCount)) %>% #to repeat the rows for interactions that have happened several times
  as.data.frame(.) %>% 
    inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Loser" = "AnimalID","Colony"="ColonyExtracted" )) %>% #this is to exclude rows where recorded loser were not part of the correct group, this include the the exclusion of unknown. The best would be to exclude unknown separately, then check when colony <> colony extracted
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID","Colony"="ColonyExtracted" ))  #this is to exclude rows where recorded winner were not part of the correct group, this include the the exclusion of unknown
  
nrow(ScanCall)
#17780 rows before any joins 
#17754 after joining on loserID and Date and Colony
#17115 after joining on WinnerID and Date and Colony. That is very strange why I lose so many rows there. I lose a lot of rows because many winners are unknown. 



#focal calls
FocalCall <- con %>%
dbGetQuery("SELECT * FROM user_philippev.SubCall_Focal") %>% 
mutate(ObsDate=as.Date(ObsDate)) %>% 
rename(NBCall=NbCall) %>% 
lapply(., function(x) rep(x,.$BehaviourCount)) %>% 
as.data.frame(.)

```


For the focal data, we the winner and the loser in a different column. In the current table this is given by the value in the column Received where 0 means winner and 1 means loser

```{r Focal Wrangling}

###Make use of the Received modifier to determine the winner and loser of each interaction and put the focal data in a format that it can be joined to scan data 
FocalCall_Tidy<- FocalCall %>% 
  filter (Received == 1) %>% 
  rename(Loser=AnimalID, Winner=Partner) %>% 
  bind_rows(FocalCall %>% 
  filter (Received == 0) %>% 
  rename(Winner=AnimalID, Loser=Partner)) %>% 
  select(-Received) %>% 
  inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Loser" = "AnimalID","Colony"="ColonyExtracted" )) %>% #this is to exclude rows where recorded loser were not part of the correct group, this include the the exclusion of unknown. The best would be to exclude unknown separately, then check when colony <> colony extracted
inner_join(.,GroupComp,by= c("ObsDate" = "filldate","Winner" = "AnimalID","Colony"="ColonyExtracted" ))  #this is to exclude rows where recorded winner were not part of the correct group, this include the the exclusion of unknown
  
nrow(FocalCall_Tidy)
#12042 without join
#11999 after loser join 
#11661 after loser and winner join 
```


We can now bind the focal and the scan data together
```{r}
SubCall_All<-FocalCall_Tidy %>% 
  bind_rows(ScanCall) %>% 
  filter (Winner != Loser) %>% #eliminate animals that interacts with themselves
  select(-BehaviourCount) %>% #could always be used in the future
  arrange(ObsDate) %>% 
  inner_join(., Sex, by=c("Winner"="AnimalID")) %>% # add the sex of the winner
  rename(SexWinner=Sex) %>% 
  inner_join(., Sex, by=c("Loser"="AnimalID")) %>% #add the sex of the loser
  rename(SexLoser=Sex) %>% 
  group_by(ObsRef,ObsType) %>%
  sample_frac(size = 1, replace = FALSE) %>% #randomize all row within each observation per type of observation
  mutate(InterractionType=ifelse(SexLoser =="F" & SexWinner=="F","Female",
     ifelse (SexWinner=="M" & SexLoser =="M","Male", "Mixed"))) %>% 
  ungroup()
  

write.csv(SubCall_All,"SubCall.csv",row.names = FALSE)

SubCall <- read.csv("SubCall.csv")

#The context given a number is wrong BECAUSE the value between scan and focal are not corresponding. Thus I would beed to bering the text. But for now it has no importance

```

There may be some colonies for which there are too few observations and that should be excluded from the analysis

```{r call summary}
Call_Summary<-SubCall_All %>% 
  group_by(Colony, ObsType) %>% 
  summarize(ObsCount=n_distinct(ObsRef)) %>% 
  arrange(ObsType,desc(ObsCount)) %>% 
  filter(Colony)

names(Call_Summary)
View(Call_Summary)

```






## Preparation of pass data set 
The idea will be to generate the elo score using pass 


