---
title: "EloCalculation"
author: "Philippe"
date: "12 November 2018"
output: html_document
editor_options: 
  chunk_output_type: console
---


We are goint to calculate the dominance index using elo rating in our captive population of Damaraland mole-rat 

```{r setup, include=FALSE}
rm(list=ls())#clean environment

library(RMySQL)
library(getPass)
library(EloRating)
library(tidyverse)
library(lubridate)
library(hms)
```

We start by establishing a connection with the database
```{r Database connection}
con <- dbConnect(MySQL(), user = 'philippev',password = getPass(),  
                 dbname = 'Moleratdatabase', host = 'Kalahariresearch.org')

#set seed to get always the same randomization
set.seed(123)
```



```{r database extract}

#get the membership from the database
Membership <- con %>%
  dbGetQuery ("SELECT 
    AnimalRef,
    AnimalID,
    DATE(MemberFrom) AS MemberFrom,
    DATE(MemberTo) AS MemberTo,
    MemberShipBetween.ColonyRef,
    MemberDays,
     MemberShipBetween.Colony AS QueriedColony,
    tblColonyCodes.ColonyOrigin
FROM
    MoleratViews_Pending.MemberShipBetween
LEFT JOIN
    Moleratdatabase.tblColonyCodes ON MoleratViews_Pending.MemberShipBetween.ColonyRef = tblColonyCodes.ColonyRef
WHERE MemberShipBetween.ColonyRef <> 120 
AND MemberShipBetween.Colony <> 'Exported_Nigel'") %>% 
  mutate(MemberFrom=ymd(MemberFrom),MemberTo=ymd(MemberTo)) %>% 
  select(AnimalRef,AnimalID,MemberFrom,MemberTo,QueriedColony,ColonyOrigin)

# I need the sex of the winner and loser to distinguish between the different type of interactions
Sex<-con %>% 
  dbGetQuery("SELECT *
FROM Moleratdatabase.tblSex
") %>% 
  select(AnimalID,Sex)

#get the weight from the database 
WeightList<-con %>% 
  dbGetQuery("SELECT * FROM user_philippev.Weight_AnimalID") %>% 
  mutate(WeightDate=ymd(WeightDate)) %>% 
  select(AnimalID,WeightDate,Weight,WeightType)

#get the individual characteristics. Regular datacheck must be carried out on this essential query
ID_Characteristic <-
  con %>% 
  dbGetQuery("SELECT * FROM user_philippev.ID_Characteristic") %>% 
  mutate(BirthDate=ymd(BirthDate),DeathDate=ymd(DeathDate),Mother_FirstLitter=ymd(Mother_FirstLitter),Father_FirstLitter=ymd(Father_FirstLitter)) %>% 
  select(AnimalID,Sex,Wildcaught,WildcaughtQueen,BirthDate,LitterRef,Mother_FirstLitter,Father_FirstLitter,DeathDate)


```


## Preparation of sub call dataset 

Extract the sub call from the scan and the focal data from the old fashion import. Thus most recend data are missing. The new fashion way will have to be added which will require a few axtra steps. The dataset of scan and focasl data are combined to increase our dataset
```{r SubCall}

#scan call
ScanCall <- con %>%
  dbGetQuery("SELECT *
FROM user_philippev.SubCall_Scan
") %>% 
  rename(Date=ObsDate) %>% 
  mutate(Date=ymd(Date)) %>% 
    lapply(., function(x) rep(x,.$BehaviourCount)) %>% #to repeat the rows for interactions that have happened several times
  as.data.frame(.) 


#focal calls
FocalCall <- con %>%
dbGetQuery("SELECT * FROM user_philippev.SubCall_Focal") %>% 
rename(Date=ObsDate,NBCall=NbCall) %>% 
mutate(Date=ymd(Date)) %>% 
lapply(., function(x) rep(x,.$BehaviourCount)) %>% 
as.data.frame(.)



#The focal dataset must be modified to be joined to the scan data 
#the AnimalID and Receiver must be assigned the label winner or loser. Received where 0 means winner and 1 means loser
FocalCall_Tidy<- FocalCall %>% 
  filter (Received == 1) %>% 
  rename(Loser=AnimalID, Winner=Partner) %>% 
  bind_rows(FocalCall %>% 
  filter (Received == 0) %>% 
  rename(Winner=AnimalID, Loser=Partner)) %>% 
  select(-Received)

#combine the dataset of the focal and of the scan
#randomize within observation session and arrange by ascending chronological order
AllCall<-FocalCall_Tidy %>% 
  bind_rows(ScanCall) %>% 
  mutate(ObsTime=as.hms(ObsTime)) %>% #for whatever reasons the lubridate hms() cannot be arranged. Ask Colin
  #GROUP BY OBSERVATION TYPE AND REF TO RANDOMIZE OBS WITHIN OBS
  group_by(ObsRef,ObsType) %>% 
  sample_frac(size = 1, replace = FALSE) %>% 
  ungroup() %>% 
#UNGROUP
  arrange(Date,ObsTime) %>% 
  mutate(InterractionRef = 1:n())  #unique idendity for each interaction and that reflects the chronological sequence after randomization 

str(AllCall)
View(AllCall)
nrow(AllCall)
#29822 calls before any tyding up  

```


The AllCall data set has to be corrected and restructured before eloratings are calculated
```{r}

#In the current dataframe the colony has been recorded manually and may be prone to mistake 
#We need to exclude interaction of individuals that interacted with themselves
#We want to exclude the interactions between individuals that belonged to different group on a given date. When interactions occurred on the day individual changed group only interactions where the queried group is similar are possible


#get winner colony 
WinnerColony <- get_Colony(
  AllCall%>% 
    select(Winner,Date)%>%
    rename(AnimalID=Winner),Membership) %>% 
  select(-ColonyOrigin)
View(WinnerColony)


#get loser colony 
LoserColony <- get_Colony(
  AllCall%>% 
    select(Loser,Date)%>%
    rename(AnimalID=Loser),Membership) %>% 
  select(-ColonyOrigin)
View(LoserColony)


AllCall_Tidy<-AllCall%>% 
  filter (Winner != Loser) %>% #eliminate animals that interacts with themselves
  inner_join(.,WinnerColony, by=c("Date"="Date","Winner"="AnimalID")) %>%
  rename(Winner_QueriedColony=QueriedColony) %>%
  inner_join(.,LoserColony, by=c("Date"="Date","Loser"="AnimalID")) %>%
  rename(Loser_QueriedColony=QueriedColony) %>% 
  filter(Loser_QueriedColony==Winner_QueriedColony) %>%  #removes interactions where colony of the winner ands loser are different. This solves the issue of sub call observed on days animals changed colonies (and are assigned two colonies) because the interaction is possible only when the colony of the winner and the colony of the loser matches. 
   inner_join(., Sex, by=c("Winner"="AnimalID")) %>% # add the sex of the winner
  rename(SexWinner=Sex) %>% 
  inner_join(., Sex, by=c("Loser"="AnimalID")) %>% #add the sex of the loser
  rename(SexLoser=Sex) %>% 
  mutate(InterractionType=ifelse(SexLoser =="F" & SexWinner=="F","Female",
     ifelse (SexWinner=="M" & SexLoser =="M","Male", "Mixed"))) %>%
  ### GROUP BY QUERIED COLONY (WINNER OR LOSER IS SAME)
  group_by(Winner_QueriedColony) %>% 
    mutate(ColonyInteraction_Count = 1:n()) %>% #total number of interaction per colony 
  ungroup()
  
  
View(AllCall_Tidy)
names(AllCall_Tidy)
nrow(AllCall_Tidy)#29771 after removing the interaction with themselves, 28833 after removing winner that have no match in WinnerColony for a given date, 28789 after removing loser that have no match in loser colony,28700 after removing mismatch between queried colony of winner and loser

#Mismatch between Colony and queried colony can at this stage be ignore
View(AllCall_Tidy %>% 
  filter(Winner_QueriedColony!=Colony))

```


Subsetting of dataset for Elo calculation. One will first only retain Colonies for which there is a total of more than 15 observations sessions
```{r}

#nb of observation sessions per colony
Call_Summary<-AllCall_Tidy  %>% 
  group_by(Colony,ObsType) %>% 
  summarize(SessionCount=n_distinct(ObsRef)) %>% 
  spread(ObsType,SessionCount) %>% 
  replace(., is.na(.), 0) %>% 
  mutate(TotalSession=Scan+Focal) %>% 
  arrange(TotalSession)
View(Call_Summary)

#colony to retain for analysis of Elo. One decides to keep colony that have had at least 15 sessions 
ColonyToRetain<-Call_Summary%>% 
  filter(TotalSession>14) %>% 
  select(Colony)


#get the dataset for elo calculation after removal of colonies for which we have had less than 15 obs sessions
AllCall_Elo<-AllCall_Tidy %>% 
  select(Winner_QueriedColony,Date,Winner,Loser,InterractionType,InterractionRef) %>% 
  rename(Colony=Winner_QueriedColony) %>% 
  inner_join(.,ColonyToRetain)

save(AllCall_Elo,file="AllCall_Elo.rda")

```




#calculation of ELO TO BE ADDED BY COLIN






#Get the individual characteristic for model TO BE DONR BY PHILIPPE

We now can add the individual characteriastic: weight, sex, breeding status
```{r individual characteristics}
# only retain the info we are interested in the weight 

```




## Preparation of pass data set 
The idea will be to generate the elo score using pass 


